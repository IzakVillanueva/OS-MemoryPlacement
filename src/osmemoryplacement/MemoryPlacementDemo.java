/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package osmemoryplacement;

import Lib.Job;
import Lib.LinkedList;
import java.awt.Color;
import java.awt.Component;
import java.awt.Dimension;
import java.awt.FlowLayout;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Random;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.BoxLayout;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JTable;
import javax.swing.JTextField;
import javax.swing.SwingConstants;
import javax.swing.table.DefaultTableModel;

/**
 *
 * @author Izak
 */
public class MemoryPlacementDemo extends javax.swing.JFrame {
    // global var
    public static DefaultTableModel memoryTbl; //the table in form
    public static DefaultTableModel scheduleTbl;
    public static DefaultTableModel scheduleTbl2;
    ArrayList<Job> jobList; // list of all jobs
    List<Job> ram = new ArrayList<>(); // jobs and holes in RAM
    List<Color> colors = new ArrayList<>(); // colors for jobs
    Job job;
    LinkedList memory; // jobs and holes in RAM using LinkedList
    JPanel ramContainer;
    JTextField ramText, chText, scText;
    boolean coalescing, coalesceFlag, inCompaction;
    List<Job> ramInComp = new ArrayList<>();;
    
    int ramSize, chTime, chCounter, scTime, scCounter;
    int timeUnit;
    int counter;
    int compRound, totalRound;
    /**
     * Creates new form MemoryPlacementDemo
     */
    public MemoryPlacementDemo() {
        initComponents();
        
        //initialize global var
        timeUnit = 0;
        memory = new LinkedList();
        inCompaction = false;
        
        ramContainer = ramPanel;
        BoxLayout boxLayout = new BoxLayout(ramContainer, BoxLayout.Y_AXIS);
        ramContainer.setLayout(boxLayout);
        ramContainer.setPreferredSize(new Dimension(190, 302));
    }
    
    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jScrollPane1 = new javax.swing.JScrollPane();
        memoryTable = new javax.swing.JTable();
        ramPanel = new javax.swing.JPanel();
        jPanel1 = new javax.swing.JPanel();
        jLabel1 = new javax.swing.JLabel();
        nextButton = new javax.swing.JButton();
        testLabel = new javax.swing.JLabel();
        jScrollPane2 = new javax.swing.JScrollPane();
        schedTable = new javax.swing.JTable();
        jScrollPane4 = new javax.swing.JScrollPane();
        schedTable2 = new javax.swing.JTable();
        startButton = new javax.swing.JButton();
        jLabel2 = new javax.swing.JLabel();
        ramTextField = new javax.swing.JTextField();
        CHTextField = new javax.swing.JTextField();
        jLabel3 = new javax.swing.JLabel();
        jLabel4 = new javax.swing.JLabel();
        jLabel5 = new javax.swing.JLabel();
        jLabel6 = new javax.swing.JLabel();
        jLabel7 = new javax.swing.JLabel();
        SCTextField = new javax.swing.JTextField();
        jLabel8 = new javax.swing.JLabel();
        jLabel9 = new javax.swing.JLabel();
        jLabel10 = new javax.swing.JLabel();
        removeButton = new javax.swing.JButton();
        addButton = new javax.swing.JButton();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        jScrollPane1.setBorder(javax.swing.BorderFactory.createEmptyBorder(1, 1, 1, 1));

        memoryTable.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0)));
        memoryTable.setFont(new java.awt.Font("Arial", 0, 14)); // NOI18N
        memoryTable.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {
                {"Job 1",  new Integer(500),  new Integer(3), null, null, null, null, null, null, null},
                {"Job 2",  new Integer(250),  new Integer(4), null, null, null, null, null, null, null},
                {"Job 3",  new Integer(200),  new Integer(5), null, null, null, null, null, null, null},
                {"Job 4",  new Integer(350),  new Integer(3), null, null, null, null, null, null, null},
                {"Job 5",  new Integer(60),  new Integer(5), null, null, null, null, null, null, null},
                {"Job 6",  new Integer(300),  new Integer(3), null, null, null, null, null, null, null},
                {"Job 7",  new Integer(400),  new Integer(2), null, null, null, null, null, null, null}
            },
            new String [] {
                "Job", "Size/KB", "Time", "Unit", "", "", "", "", "", ""
            }
        ) {
            Class[] types = new Class [] {
                java.lang.String.class, java.lang.Integer.class, java.lang.Integer.class, java.lang.Integer.class, java.lang.Integer.class, java.lang.Integer.class, java.lang.Integer.class, java.lang.Integer.class, java.lang.Integer.class, java.lang.Integer.class
            };
            boolean[] canEdit = new boolean [] {
                false, true, true, false, false, false, false, false, false, false
            };

            public Class getColumnClass(int columnIndex) {
                return types [columnIndex];
            }

            public boolean isCellEditable(int rowIndex, int columnIndex) {
                return canEdit [columnIndex];
            }
        });
        memoryTable.setRowHeight(27);
        memoryTable.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyTyped(java.awt.event.KeyEvent evt) {
                memoryTableKeyTyped(evt);
            }
        });
        jScrollPane1.setViewportView(memoryTable);
        if (memoryTable.getColumnModel().getColumnCount() > 0) {
            memoryTable.getColumnModel().getColumn(2).setPreferredWidth(50);
            memoryTable.getColumnModel().getColumn(3).setResizable(false);
            memoryTable.getColumnModel().getColumn(3).setPreferredWidth(50);
            memoryTable.getColumnModel().getColumn(4).setResizable(false);
            memoryTable.getColumnModel().getColumn(4).setPreferredWidth(50);
            memoryTable.getColumnModel().getColumn(5).setResizable(false);
            memoryTable.getColumnModel().getColumn(5).setPreferredWidth(50);
            memoryTable.getColumnModel().getColumn(6).setResizable(false);
            memoryTable.getColumnModel().getColumn(6).setPreferredWidth(50);
            memoryTable.getColumnModel().getColumn(7).setResizable(false);
            memoryTable.getColumnModel().getColumn(7).setPreferredWidth(50);
            memoryTable.getColumnModel().getColumn(8).setResizable(false);
            memoryTable.getColumnModel().getColumn(8).setPreferredWidth(50);
            memoryTable.getColumnModel().getColumn(9).setResizable(false);
            memoryTable.getColumnModel().getColumn(9).setPreferredWidth(50);
        }

        ramPanel.setBackground(new java.awt.Color(238, 238, 138));
        ramPanel.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0)));
        ramPanel.setPreferredSize(new java.awt.Dimension(192, 302));

        jPanel1.setBackground(new java.awt.Color(238, 238, 138));
        jPanel1.setPreferredSize(new java.awt.Dimension(190, 302));

        jLabel1.setForeground(new java.awt.Color(0, 0, 0));
        jLabel1.setText("Hole - 1000");

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel1Layout.createSequentialGroup()
                .addContainerGap(66, Short.MAX_VALUE)
                .addComponent(jLabel1)
                .addGap(60, 60, 60))
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addGap(140, 140, 140)
                .addComponent(jLabel1)
                .addContainerGap(144, Short.MAX_VALUE))
        );

        javax.swing.GroupLayout ramPanelLayout = new javax.swing.GroupLayout(ramPanel);
        ramPanel.setLayout(ramPanelLayout);
        ramPanelLayout.setHorizontalGroup(
            ramPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(ramPanelLayout.createSequentialGroup()
                .addComponent(jPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(0, 0, Short.MAX_VALUE))
        );
        ramPanelLayout.setVerticalGroup(
            ramPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, 300, Short.MAX_VALUE)
        );

        nextButton.setText("Next");
        nextButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                nextButtonActionPerformed(evt);
            }
        });

        testLabel.setText("jLabel1");

        jScrollPane2.setBorder(javax.swing.BorderFactory.createEmptyBorder(1, 1, 1, 1));

        schedTable.setFont(new java.awt.Font("sansserif", 1, 16)); // NOI18N
        schedTable.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {
                {null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null}
            },
            new String [] {
                "1", "Title 2", "Title 3", "Title 4", "Title 5", "Title 6", "Title 7", "Title 8", "Title 9", "Title 10", "Title 11", "Title 12", "Title 13", "null", "null", "null", "null"
            }
        ) {
            boolean[] canEdit = new boolean [] {
                false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false
            };

            public boolean isCellEditable(int rowIndex, int columnIndex) {
                return canEdit [columnIndex];
            }
        });
        schedTable.setAutoResizeMode(javax.swing.JTable.AUTO_RESIZE_ALL_COLUMNS);
        schedTable.setRowHeight(50);
        schedTable.setTableHeader(null);
        jScrollPane2.setViewportView(schedTable);

        jScrollPane4.setBorder(javax.swing.BorderFactory.createEmptyBorder(1, 1, 1, 1));

        schedTable2.setFont(new java.awt.Font("sansserif", 1, 16)); // NOI18N
        schedTable2.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {
                {null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null}
            },
            new String [] {
                "1", "Title 2", "Title 3", "Title 4", "Title 5", "Title 6", "Title 7", "Title 8", "Title 9", "Title 10", "Title 11", "Title 12", "Title 13", "Title 14", "null", "null", "null"
            }
        ) {
            boolean[] canEdit = new boolean [] {
                false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false
            };

            public boolean isCellEditable(int rowIndex, int columnIndex) {
                return canEdit [columnIndex];
            }
        });
        schedTable2.setAutoResizeMode(javax.swing.JTable.AUTO_RESIZE_ALL_COLUMNS);
        schedTable2.setRowHeight(50);
        schedTable2.setTableHeader(null);
        jScrollPane4.setViewportView(schedTable2);

        startButton.setText("Start");
        startButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                startButtonActionPerformed(evt);
            }
        });

        jLabel2.setText("Given:");

        ramTextField.setText("1000");
        ramTextField.setToolTipText("<ram amount>");

        CHTextField.setText("1");
        CHTextField.setToolTipText("time unit");
        CHTextField.setMinimumSize(new java.awt.Dimension(30, 28));
        CHTextField.setPreferredSize(new java.awt.Dimension(30, 28));

        jLabel3.setText("KB");

        jLabel4.setText("of RAM");

        jLabel5.setText("Coalescing -");

        jLabel6.setText("TU");

        jLabel7.setText("Storage Compaction");

        SCTextField.setText("20");
        SCTextField.setToolTipText("time unit");
        SCTextField.setMinimumSize(new java.awt.Dimension(30, 28));
        SCTextField.setPreferredSize(new java.awt.Dimension(30, 28));

        jLabel8.setText("every");

        jLabel9.setText("TU");

        jLabel10.setText("First Fit Strategy");

        removeButton.setText("Remove Row");
        removeButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                removeButtonActionPerformed(evt);
            }
        });

        addButton.setText("Add Row");
        addButton.setPreferredSize(new java.awt.Dimension(102, 28));
        addButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                addButtonActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGap(123, 123, 123)
                        .addComponent(startButton)
                        .addGap(98, 98, 98)
                        .addComponent(nextButton))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(21, 21, 21)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                            .addComponent(jScrollPane4, javax.swing.GroupLayout.PREFERRED_SIZE, 776, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 776, javax.swing.GroupLayout.PREFERRED_SIZE)))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(21, 21, 21)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                            .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 422, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addGroup(javax.swing.GroupLayout.Alignment.LEADING, layout.createSequentialGroup()
                                .addComponent(removeButton)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(addButton, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)))
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(layout.createSequentialGroup()
                                .addGap(41, 41, 41)
                                .addComponent(ramPanel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addComponent(jLabel2)
                                    .addGroup(layout.createSequentialGroup()
                                        .addGap(6, 6, 6)
                                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                            .addGroup(layout.createSequentialGroup()
                                                .addComponent(CHTextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                                                .addGap(3, 3, 3)
                                                .addComponent(jLabel6))
                                            .addComponent(jLabel4)
                                            .addComponent(jLabel5)
                                            .addComponent(jLabel7)
                                            .addGroup(layout.createSequentialGroup()
                                                .addComponent(jLabel8)
                                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                                .addComponent(SCTextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                                .addComponent(jLabel9))
                                            .addComponent(jLabel10)))
                                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                                        .addComponent(ramTextField, javax.swing.GroupLayout.PREFERRED_SIZE, 85, javax.swing.GroupLayout.PREFERRED_SIZE)
                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                        .addComponent(jLabel3)
                                        .addGap(20, 20, 20))))
                            .addGroup(layout.createSequentialGroup()
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                .addComponent(testLabel)
                                .addGap(209, 209, 209)))))
                .addContainerGap(10, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addContainerGap()
                        .addComponent(ramPanel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(39, 39, 39)
                        .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 266, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(26, 26, 26)
                        .addComponent(jLabel2)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(ramTextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(jLabel3))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jLabel4)
                        .addGap(14, 14, 14)
                        .addComponent(jLabel5)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(CHTextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(jLabel6))
                        .addGap(18, 18, 18)
                        .addComponent(jLabel7)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jLabel8)
                            .addComponent(SCTextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(jLabel9))
                        .addGap(18, 18, 18)
                        .addComponent(jLabel10)))
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGap(18, 18, 18)
                        .addComponent(testLabel))
                    .addGroup(layout.createSequentialGroup()
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(removeButton)
                            .addComponent(addButton, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))))
                .addGap(32, 32, 32)
                .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 84, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(18, 18, 18)
                .addComponent(jScrollPane4, javax.swing.GroupLayout.PREFERRED_SIZE, 84, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 11, Short.MAX_VALUE)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(nextButton)
                    .addComponent(startButton))
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void nextButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_nextButtonActionPerformed
        scheduleTbl = (DefaultTableModel) schedTable.getModel();
        scheduleTbl2 = (DefaultTableModel) schedTable2.getModel();
        memoryTbl = (DefaultTableModel) memoryTable.getModel();
        JLabel text = testLabel;
        boolean holeFlag = true;
        boolean jobExist = false;
        coalesceFlag = true;
        int rowCount = memoryTbl.getRowCount();
        System.out.println("=============NEW "+timeUnit+"===============");
        
        ram = memory.showMemory();
        for(Job j : ram){
            if(!j.isHole()){
                jobExist = true;
            }
        }
        if(!jobExist && timeUnit>2){
            coalscer("finish");
            return;
        }
        
        //  STORAGE COMPACTION ================================================================================
        ram = memory.showMemory();
        if(timeUnit == scCounter){ // if its that every TU for SC
            ramInComp = memory.showMemory();
            inCompaction = true;
            totalRound = 0;
            compRound = 0;
            for(Job j : ram){
                if(!j.isHole()){
                    totalRound++;
                }
            }
            scCounter += scTime;
        }
        if(inCompaction && compRound<totalRound){
            ram = memory.showMemory();
            Job largestJob = null;
            boolean repeat = true;
            while(repeat && compRound < totalRound){
                int place = 0, largest = 0;
                for(Job j : ramInComp){ //get largest job
                    if(!j.isHole()){
                        if(j.getSize()>largest){
                            largest = j.getSize();
                            largestJob = j;
                        }
                    }
                }
                for(Job j : ram) { // finds the order of largest
                    if(j == largestJob){
                        System.out.println("hi there");
                        break;
                    }
                    place++;
                }
                if(place == compRound){
                    System.out.println("YOOOOOOOOOO");
                    repeat = true;
                    ramInComp.remove(largestJob);
                    compRound++;
                }
                else{
                    repeat = false;
                    ramInComp.remove(largestJob);
                }
            }
            if(compRound < totalRound){
                int ite = 0;
                for(Job j : ram){ //removes largest Job in ram
                    if(j == largestJob){
                        memory.deleteAt(ite);
                        break;
                    }
                    ite++;
                }
                memory.insertAt(compRound, largestJob);
                updateSchedTbl(0, "SC");
                ramUpdater();
                compRound++;
                memory.printMemory();
                return;
            }
        }
        if(compRound == totalRound && inCompaction){ //coalesce the final hole
            inCompaction = false;
            coalscer("SC");
            return;
        }
        
        // CHECK FOR COALESC ==================================================================================
        coalscer("");
        
        for(Job j : jobList){ //add counter if job is not in memory
            if(jobList.get(counter).isInMemory()){
                break;
            }else{
                counterAdd();
            }
        }
        
        // ADD JOBS IN HOLE ====================================================================================
        if(!coalesceFlag){
            for(int i=0; i<rowCount; i++){ //traverses each of the job only for joblist (i is row)
                if(!(jobList.get(i).isInMemory()) && !(jobList.get(i).isDone()) && !(jobList.get(i).isHole())){ //check if normal job
                    if(checkSpace(jobList.get(i).getSize())){
                        //add job to memory
                        addJob(jobList.get(i).getSize(), jobList.get(i));
                        jobList.get(i).setInMemory(true);
                        //System.out.println("add");
                        //System.out.println(jobList.get(i).getName() + jobList.get(i).isInMemory());
                        //add to table and minus the time unit
                        updateMemTbl(i);

                        //add to time schedule
                        updateSchedTbl(i, "");

                        //update ram
                        ramUpdater();
                        break;
                    }
                }
                if(i == rowCount-1){ // flag if no jobs can be placed in holes
                    holeFlag = false;
                    break;
                }
            }
        }
        
        System.out.println("existing===");
        // PROCESS EXISTING JOBS ====================================================================================
        if(!holeFlag){
            System.out.println("process exist");
            ram = memory.showMemory();
            for(Job j : jobList){ //add counter if not in memory
                if(jobList.get(counter).isInMemory()){
                    break;
                }else{
                    counterAdd();
                }
            }
            System.out.println("added"+counter);
            //System.out.println("hey"+counter);
            for(Job j : ram){ //traverse each job or hole in ram
                if(!j.isHole()){ //if job in ram is not hole
                    Job currJob = jobList.get(counter);
                    if(j == currJob){ //if equal to counter
                        //add to table and minus the time unit
                        updateMemTbl(counter);

                        //add to time schedule
                        updateSchedTbl(counter, "");
                        counterAdd();
                        break;
                    }
                }
            }
            holeFlag = true;
        }
        
        System.out.println("=============END===============");
        memory.printMemory();
        //System.out.print(ram.get(1).getTime());  
        //text.setText(String.valueOf(jobList.get(2).getSize())); //label tester
        //System.out.print(job.getSize());      
        //memoryTbl.setValueAt(5, 4, 4); for setting specific cells
    }//GEN-LAST:event_nextButtonActionPerformed

    private void memoryTableKeyTyped(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_memoryTableKeyTyped
        memoryTbl = (DefaultTableModel) memoryTable.getModel(); //to update table values
    }//GEN-LAST:event_memoryTableKeyTyped

    private void startButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_startButtonActionPerformed
        ramSize = Integer.valueOf(ramTextField.getText());
        chTime = Integer.valueOf(CHTextField.getText());
        chCounter = chTime;
        scTime = Integer.valueOf(SCTextField.getText());
        scCounter = scTime;
        job = new Job("Hole", ramSize, 0, true, false, true); // initial hole node
        memory.insert(job); //initialize hole node
        jLabel1.setText("Hole - " + ramSize);
        
        memoryTbl = (DefaultTableModel) memoryTable.getModel();
        int rowCount = memoryTbl.getRowCount();
        jobList = new ArrayList<Job>(); //takes data from table and add jobs to list
        for(int i=0; i<rowCount; i++){
            for(int j=0; j<memoryTbl.getColumnCount(); j++){ 
                if(j==0){ //doesnt include holes
                    job = new Job(memoryTbl.getValueAt(i, j).toString(),(int)memoryTbl.getValueAt(i, j+1), (int)memoryTbl.getValueAt(i, j+2), false, false, false);
                    jobList.add(job);
                }
            }
        }
        colorCreator();
        removeButton.setEnabled(false);
        addButton.setEnabled(false);
        ramTextField.setEditable(false);
        CHTextField.setEditable(false);
        SCTextField.setEditable(false);
        startButton.setEnabled(false);
        memoryTable.setEnabled(false);
    }//GEN-LAST:event_startButtonActionPerformed

    private void removeButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_removeButtonActionPerformed
        memoryTbl = (DefaultTableModel) memoryTable.getModel();
        memoryTbl.removeRow(memoryTbl.getRowCount()-1);
    }//GEN-LAST:event_removeButtonActionPerformed

    private void addButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_addButtonActionPerformed
        memoryTbl = (DefaultTableModel) memoryTable.getModel();
        int row = memoryTbl.getRowCount()+1;
        Object[] rowData = {("Job " + row)};
        memoryTbl.addRow(rowData);
    }//GEN-LAST:event_addButtonActionPerformed
    

// CUSTOM FUNCTIONS ========================================================================================================
    private boolean checkSpace(int size){
        System.out.println("SPACE CHECKER");
        ram = memory.showMemory(); // list of those in ram because it cant return
        for(Job j : ram){
            if(j.isHole() == true){ //gets each hole
                if(j.getSize() >= size){
                    return true;
                }
            }
        }
        return false;
    }
    
    private boolean addJob(int size, Job tba){ //for putting jobs into holes
        System.out.println("ADD JOB");
        ram = memory.showMemory(); // list of those in ram because it cant return
        int i = 0;
        for(Job j : ram){
            if(j.isHole()){ //gets each hole
                if(j.getSize() >= size){
                    memory.deleteAt(i);
                    memory.insertAt(i, tba);
                    if(j.getSize() > size){
                        job = new Job("Hole", (j.getSize()-size), 0, true, false, true); // new hole node
                        memory.insertAt(i+1, job);
                    }
                    return true;
                }
            }
            i++;
        }
        return false;
    }
    
    private int memorySizer(int size){//gets the size of space allocation
        System.out.println("MEMORYSIZER");
        float percentage = (float)size/ramSize;
        float allocated = (float)percentage*ramContainer.getHeight();
        return (int)allocated;
    }
    
    private void updateMemTbl(int iterator){ //add to table and minus the time unit
        System.out.println("UPDATE-MEMTBL");
        for(int m=0; m<memoryTbl.getColumnCount(); m++){ //traverses memoryTable, m = column
            if(memoryTbl.getValueAt(iterator, m) == null){
                Job currJob = jobList.get(iterator);
                System.out.println(currJob.getName());
                currJob.setTime(currJob.getTime()-1);
                if(currJob.getTime() == 0){ // if 0, delete
                    memoryTbl.setValueAt("*", iterator, m);
                    currJob.setDone(true);
                    
                    ram = memory.showMemory(); 
                    int i = 0;
                    for(Job j : ram){ //replace with hole node
                        if(j == currJob){
                            memory.deleteAt(i);
                            currJob.setInMemory(false);
                            job = new Job("Hole", currJob.getSize(), 0, true, false, true); // new hole node
                            memory.insertAt(i, job);
                            ramUpdater();
                            //replace panel with hole node
                            //panelToHole(jobList.get(iterator).getName(), iterator);
                            break;
                        }
                        i++;
                    }
                }else{
                    memoryTbl.setValueAt(jobList.get(iterator).getTime(), iterator, m);
                }
                break;
            }
        }
    }
    
    private void updateSchedTbl(int iterator, String type){
        System.out.println("UPDATE=SCHEDTBL");
        if(type.equalsIgnoreCase("CH") || type.equalsIgnoreCase("SC")){ // for coalescing and compaction
            if(timeUnit<17){ 
                for(int s=0; s<scheduleTbl.getColumnCount(); s++){ //traverses schedule Table
                    if(scheduleTbl.getValueAt(0, s)==null){
                        scheduleTbl.setValueAt(type, 0, s);
                        timeUnit++;
                        break;
                    }
                }
            }else{
                for(int s=0; s<scheduleTbl2.getColumnCount(); s++){ //traverses schedule Table
                    if(scheduleTbl2.getValueAt(0, s)==null){
                        scheduleTbl2.setValueAt(type, 0, s);
                        timeUnit++;
                        break;
                    }
                }
            }
        }
        else{ // for normal jobs
            if(timeUnit<17){ 
                for(int s=0; s<scheduleTbl.getColumnCount(); s++){ //traverses schedule Table
                    if(scheduleTbl.getValueAt(0, s)==null){
                        scheduleTbl.setValueAt(jobList.get(iterator).getName(), 0, s);
                        timeUnit++;
                        break;
                    }
                }
            }else{
                for(int s=0; s<scheduleTbl2.getColumnCount(); s++){ //traverses schedule Table
                    if(scheduleTbl2.getValueAt(0, s)==null){
                        scheduleTbl2.setValueAt(jobList.get(iterator).getName(), 0, s);
                        timeUnit++;
                        break;
                    }
                }
            }
        }
    }
    
    private void ramUpdater(){
        System.out.println("RAM-UPDATE");
        int order = 0;
        ramContainer.removeAll();
        
        ram = memory.showMemory();
        for(Job j : ram){
            if(j.isInMemory()){
                JPanel process = new JPanel();
                process.add(new JLabel((ram.get(order).getName()+" - "+ram.get(order).getSize()), SwingConstants.CENTER));
                if(j.isHole()){
                    process.setBackground(new Color(238, 238, 138));
                } else{
                    process.setBackground(colors.get(returnOrder(j)));
                }
                int height = memorySizer((int)ram.get(order).getSize());
                process.setPreferredSize(new Dimension(190, height));
                process.setMaximumSize(new Dimension(190, height));
                ramContainer.add(process);
                order++;
            }
        }
        //System.out.println("UPDATE DONE==========");
        ramContainer.revalidate();
        ramContainer.repaint();
    }
    
    private void colorCreator(){
        Random rand = new Random();
        for(Job j : jobList){
            int r = rand.nextInt(120)+100;
            int g = rand.nextInt(120)+100;
            int b = rand.nextInt(120)+100;
            Color randColor = new Color(r, g, b);
            colors.add(randColor);
        }
    }
    
    private int returnOrder(Job j){
        int i = 0;
        for(Job x : jobList){
            if(x == j){
                return i;
            }
            i++;
        }
        return i;
    }
    
    private void counterAdd(){
        counter++;
        if(!(counter<(jobList.size()))){ //reset counter
            counter = 0; // this is iterator for memoryList
        }
    }
    
    private void coalscer(String type){
        boolean finish = true;
        for(Job j : ram){
            if(!j.isHole()){
                finish = false;
            }
        }
        if((timeUnit&chTime) == 0 || type == "SC" || finish == true){
            ram = memory.showMemory();
            coalescing = false;
            for(int r=0;r<=3;r++){ // for loop to combine holes if there are more than 2 beside each other
                int g=0; // counter for getting element
                for (Job butas : ram) { 
                    if(butas.isHole()){
                        Job nextButas = memory.getNext(g);
                        if(nextButas == null){
                            break;
                        }
                        if(nextButas.getName().contains("Hole")){ // if two holes are next to each other
                            int holeSize = butas.getSize() + nextButas.getSize();
                            memory.deleteAt(g+1);
                            memory.deleteAt(g);
                            Job newButas = new Job("Hole", holeSize, 0, true, false, true);
                            memory.insertAt(g, newButas);
                            //update ram
                            ramUpdater();
                            coalescing = true;
                            break;
                        }
                    }
                    g++;
                }
                if(r==3 && coalescing){ // 
                    //update schedTbl
                    if("SC".equals(type)){
                        updateSchedTbl(0, "SC");
                    } else if("finish".equals(type)){

                    } else{
                        updateSchedTbl(0, "CH");
                    }
                    coalesceFlag = true;
                    return;
                }
            }
        }
        coalesceFlag = false;
    }
    
    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new MemoryPlacementDemo().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JTextField CHTextField;
    private javax.swing.JTextField SCTextField;
    private javax.swing.JButton addButton;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel10;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JLabel jLabel6;
    private javax.swing.JLabel jLabel7;
    private javax.swing.JLabel jLabel8;
    private javax.swing.JLabel jLabel9;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JScrollPane jScrollPane4;
    private javax.swing.JTable memoryTable;
    private javax.swing.JButton nextButton;
    private javax.swing.JPanel ramPanel;
    private javax.swing.JTextField ramTextField;
    private javax.swing.JButton removeButton;
    private javax.swing.JTable schedTable;
    private javax.swing.JTable schedTable2;
    private javax.swing.JButton startButton;
    private javax.swing.JLabel testLabel;
    // End of variables declaration//GEN-END:variables
}
